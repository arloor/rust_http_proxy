# 反向代理流量统计说明

本文档详细说明反向代理场景下的两种流量统计实现方式及其使用场景。

## 概述

反向代理的流量统计在两个不同的层次实现：

1. **CounterHyperIO**: TCP/IO 连接层统计
2. **CounterBody**: HTTP Body Stream 层统计

这两种方式互补，共同提供完整的流量可观测性。

---

## 一、CounterHyperIO - 连接层流量统计

### 1.1 实现位置

文件：`rust_http_proxy/src/proxy.rs`

```rust
pub struct CounterHyperIO<T, R> {
    inner: T,                           // 底层 IO 对象
    traffic_counter: Family<R, Counter>, // Prometheus 计数器
    label: R,                           // 流量标签
}
```

### 1.2 工作原理

- **包装层次**: 包装 `hyper::rt::Read` 和 `hyper::rt::Write` trait
- **统计位置**: 在 TCP 连接的读写操作中统计
- **使用场景**: 通过 `CounterConnector` 包装 `HttpsConnector`，用于 hyper legacy client

### 1.3 实现细节

#### Write 端统计（准确）

```rust
impl<T, R> hyper::rt::Write for CounterHyperIO<T, R> {
    fn poll_write(self: Pin<&mut Self>, cx: &mut Context, buf: &[u8])
        -> Poll<Result<usize, Error>>
    {
        let this = self.project();
        match this.inner.poll_write(cx, buf) {
            Poll::Ready(result) => {
                if let Ok(size) = result {
                    // 统计写入的字节数
                    this.traffic_counter.get_or_create(this.label).inc_by(size as u64);
                }
                Poll::Ready(result)
            }
            other => other,
        }
    }
}
```

**统计内容**：

- ✅ 客户端发送到上游服务器的请求数据（请求头 + 请求体）
- ✅ 包括所有 HTTP/1.1、HTTP/2 的协议数据
- ✅ TLS 加密前的原始数据

#### Read 端统计（受限）

```rust
impl<T, R> hyper::rt::Read for CounterHyperIO<T, R> {
    fn poll_read(self: Pin<&mut Self>, cx: &mut Context, buf: ReadBufCursor)
        -> Poll<Result<(), Error>>
    {
        // 由于 ReadBufCursor 在 poll_read 调用后被移动，
        // 无法在此准确统计读取的字节数
        this.inner.poll_read(cx, buf)
    }
}
```

**限制**：

- ❌ 无法准确统计从上游服务器接收的响应数据
- **原因**: `hyper::rt::ReadBufCursor` API 设计限制，调用后缓冲区被移动
- **解决方案**: 使用 CounterBody 在 HTTP body 层面统计

### 1.4 在反向代理中的使用

通过 `build_hyper_legacy_client_with_counter` 函数创建带流量统计的 HTTP 客户端：

```rust
// proxy.rs
pub fn new(config: Arc<Config>) -> Result<Self, DynError> {
    let reverse_client = build_hyper_legacy_client_with_counter(
        METRICS.proxy_traffic.clone(),
        reverse_proxy_label_fn,  // 标签生成函数
    );

    Ok(ProxyHandler {
        reverse_proxy_client: reverse_client,
        // ...
    })
}
```

**流量标签**：

```rust
fn reverse_proxy_label_fn(uri: &Uri) -> LabelImpl<AccessLabel> {
    LabelImpl::new(AccessLabel {
        client: "reverse_proxy".to_owned(),
        target: uri.authority().map(|a| a.to_string()).unwrap_or_default(),
        username: "reverse_proxy".to_owned(),
        relay_over_tls: None,
    })
}
```

### 1.5 统计覆盖范围

| 方向 | 内容   | 是否统计 | 统计层次  |
| ---- | ------ | -------- | --------- |
| 出站 | 请求头 | ✅       | TCP Write |
| 出站 | 请求体 | ✅       | TCP Write |
| 入站 | 响应头 | ❌       | -         |
| 入站 | 响应体 | ❌       | -         |

---

## 二、CounterBody - HTTP Body Stream 层统计

### 2.1 实现位置

文件：`rust_http_proxy/src/proxy.rs`

```rust
pub struct CounterBody<B, R>
where
    R: prom_label::Label,
{
    inner: B,                           // 原始 Body
    traffic_counter: Family<R, Counter>, // Prometheus 计数器
    label: R,                           // 流量标签
}
```

### 2.2 工作原理

- **包装层次**: 包装任何实现 `http_body::Body` trait 的 body
- **统计位置**: 在 HTTP body stream 的 `poll_frame` 中统计
- **使用场景**: 包装反向代理从上游服务器接收的响应 body

### 2.3 实现细节

```rust
impl<B, R> http_body::Body for CounterBody<B, R>
where
    B: http_body::Body<Data = Bytes>,
    R: prom_label::Label + Clone,
{
    fn poll_frame(
        self: Pin<&mut Self>,
        cx: &mut Context,
    ) -> Poll<Option<Result<http_body::Frame<Self::Data>, Self::Error>>> {
        let this = self.project();

        match this.inner.poll_frame(cx) {
            Poll::Ready(Some(Ok(frame))) => {
                // 如果是数据帧，统计字节数
                if let Some(data) = frame.data_ref() {
                    let bytes = data.len() as u64;
                    this.traffic_counter.get_or_create(this.label).inc_by(bytes);
                }
                Poll::Ready(Some(Ok(frame)))
            }
            other => other,
        }
    }
}
```

**统计内容**：

- ✅ HTTP 响应体的所有数据块
- ✅ 精确统计，不受协议版本影响
- ✅ 只统计实际的 body 数据，不包括响应头

### 2.4 在反向代理中的使用

文件：`rust_http_proxy/src/location.rs`

```rust
match reverse_client.request(upstream_req).await {
    Ok(mut resp) => {
        // ... 处理 302 重定向等逻辑

        // 创建流量统计标签
        let traffic_label = AccessLabel {
            client: "reverse_proxy_response".to_owned(),
            target: upstream.url_base.clone(),
            username: "reverse_proxy".to_owned(),
            relay_over_tls: None,
        };

        Ok(resp.map(|body| {
            // 使用 CounterBody 包装响应 body
            let counter_body = CounterBody::new(
                body,
                METRICS.proxy_traffic.clone(),
                LabelImpl::new(traffic_label),
            );

            counter_body
                .map_err(|e| io::Error::new(ErrorKind::InvalidData, e))
                .boxed()
        }))
    }
}
```

### 2.5 统计覆盖范围

| 内容         | 是否统计 | 统计层次         |
| ------------ | -------- | ---------------- |
| 响应体数据   | ✅       | HTTP Body Stream |
| 响应头       | ❌       | -                |
| 传输编码开销 | ❌       | -                |

---

## 三、两种方式的对比

### 3.1 功能对比

| 特性         | CounterHyperIO             | CounterBody                 |
| ------------ | -------------------------- | --------------------------- |
| **统计层次** | TCP/IO 连接层              | HTTP Body Stream 层         |
| **统计粒度** | 字节级（包含协议开销）     | 数据块级（纯应用数据）      |
| **实现位置** | hyper::rt::Read/Write      | http_body::Body::poll_frame |
| **请求出站** | ✅ 完整统计                | ❌ 不适用                   |
| **响应入站** | ❌ API 限制                | ✅ 完整统计                 |
| **协议开销** | ✅ 包含                    | ❌ 不包含                   |
| **使用难度** | 中等（需要包装 Connector） | 简单（直接包装 Body）       |

### 3.2 适用场景

#### CounterHyperIO 适用于：

- ✅ 统计客户端发送的请求流量
- ✅ 需要包含协议层开销的场景
- ✅ 在连接建立时就需要统计的场景
- ✅ 统计整个连接的生命周期流量

#### CounterBody 适用于：

- ✅ 统计服务器响应的 body 流量
- ✅ 需要精确的应用层数据统计
- ✅ 按请求/响应维度统计
- ✅ 需要细粒度控制统计标签的场景

---

## 四、完整的反向代理流量统计架构

### 4.1 数据流向

```
客户端请求
    ↓
[proxy.rs] 接收请求
    ↓
[location.rs] 判定为反向代理
    ↓
构建上游请求 (upstream_req)
    ↓
[CounterHyperIO] ← reverse_client.request()  → 上游服务器
    ↑ Write 端统计                              (请求发送)
    | ✅ 请求头 + 请求体
    |
[上游服务器响应]
    ↓
[CounterBody] ← 包装响应 body
    ↓ 统计响应体数据
    | ✅ 响应体
    ↓
返回给客户端
```

### 4.2 Prometheus 指标

两种统计方式共享同一个 Prometheus 指标：

```rust
METRICS.proxy_traffic  // Family<LabelImpl<AccessLabel>, Counter>
```

**标签区分**：

| 统计方式       | client 标签值            | target 标签值          | 说明         |
| -------------- | ------------------------ | ---------------------- | ------------ |
| CounterHyperIO | "reverse_proxy"          | upstream URI authority | 请求发送流量 |
| CounterBody    | "reverse_proxy_response" | upstream.url_base      | 响应接收流量 |

### 4.3 查询示例

**查询反向代理发送的请求流量**：

```promql
proxy_traffic{client="reverse_proxy"}
```

**查询反向代理接收的响应流量**：

```promql
proxy_traffic{client="reverse_proxy_response"}
```

**查询特定上游服务的总流量**：

```promql
sum(proxy_traffic{target=~"api.example.com.*"})
```

---

## 五、与其他场景的统计对比

### 5.1 正向代理隧道（CONNECT）

使用 `CounterIO`（在 `io_x` crate 中）：

```rust
// proxy.rs - tunnel_proxy 函数
let dst_stream = CounterIO::new(
    target_stream,
    proxy_traffic,
    LabelImpl::new(access_label)
);

tunnel(src_upgraded, dst_stream).await
```

**特点**：

- ✅ 双向流量统计（Read + Write）
- ✅ 在 `tokio::io::AsyncRead/AsyncWrite` 层实现
- ✅ 适用于原始 TCP 流量转发

### 5.2 正向代理普通请求（GET/POST）

使用 `CounterIO` + `EitherTlsStream`：

```rust
// proxy.rs - simple_proxy 函数
self.forward_proxy_client.send_request(
    req,
    &access_label,
    |stream: EitherTlsStream, access_label: AccessLabel| {
        CounterIO::new(stream, METRICS.proxy_traffic.clone(), LabelImpl::new(access_label))
    }
)
```

**特点**：

- ✅ 双向流量统计
- ✅ 支持 TCP 和 TLS 流
- ✅ 在 forward_proxy_client 内部处理

### 5.3 统计架构总览

```
┌─────────────────────────────────────────────────────────┐
│                  Rust HTTP Proxy 流量统计                │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  正向代理                    │  反向代理                  │
│  ─────────────────────────  │  ──────────────────────── │
│                             │                           │
│  • CONNECT 隧道             │  • 请求发送（出站）         │
│    └─ CounterIO             │    └─ CounterHyperIO      │
│       (双向统计)             │       (Write 端)          │
│                             │                           │
│  • GET/POST 等              │  • 响应接收（入站）         │
│    └─ CounterIO             │    └─ CounterBody         │
│       (双向统计)             │       (Body Stream)       │
│                             │                           │
└─────────────────────────────────────────────────────────┘
```

---

## 六、最佳实践建议

### 6.1 何时使用 CounterHyperIO

1. ✅ 构建 hyper HTTP 客户端时（在 Connector 层包装）
2. ✅ 需要统计完整的 TCP 流量（包括协议开销）
3. ✅ 发送方向的流量统计
4. ✅ 需要在连接级别进行统计

### 6.2 何时使用 CounterBody

1. ✅ 需要统计 HTTP 响应 body 的具体数据量
2. ✅ 需要区分不同请求的响应流量
3. ✅ 只关心应用层数据，不关心协议开销
4. ✅ 需要灵活控制统计标签（按请求维度）

### 6.3 性能考虑

- **CounterHyperIO**:
  - 开销：每次 `poll_write`/`poll_read` 调用时增加计数器
  - 影响：极小，计数器操作是原子操作
- **CounterBody**:
  - 开销：每个数据帧（Frame）增加一次计数器
  - 影响：极小，HTTP/2 帧、HTTP/1.1 数据块都是较大单位

### 6.4 标签设计建议

**良好的标签设计**：

```rust
AccessLabel {
    client: "reverse_proxy_response",  // 明确统计来源
    target: upstream.url_base.clone(), // 上游服务标识
    username: "reverse_proxy",         // 区分不同代理类型
    relay_over_tls: None,              // 额外的维度信息
}
```

**避免高基数标签**：

- ❌ 不要使用完整的 URL（包含 query 参数）
- ❌ 不要使用时间戳
- ❌ 不要使用客户端 IP（如果客户端很多）
- ✅ 使用聚合后的标识（如域名、服务名）

---

## 七、故障排查

### 7.1 流量统计不准确

**问题**: CounterHyperIO 只统计到出站流量，没有入站流量

**原因**: Read 端受 API 限制无法统计

**解决**: 使用 CounterBody 补充入站流量统计

### 7.2 标签不匹配

**问题**: 在 Prometheus 中查询不到预期的标签

**原因**: 可能是标签值拼写错误或使用了动态值

**排查**:

```rust
// 添加日志查看实际的标签值
info!("Traffic label: {:?}", traffic_label);
```

### 7.3 内存泄漏

**问题**: Prometheus 指标占用内存持续增长

**原因**: 标签基数过高（每个唯一的标签组合都会创建一个新的计数器）

**解决**:

- 限制标签的可能值范围
- 使用聚合标签而非原始值
- 定期清理不活跃的指标（需要额外实现）

---

## 八、未来改进方向

### 8.1 增强 CounterHyperIO 的 Read 端统计

可能的方案：

- 包装 `ReadBuf` 而非 `ReadBufCursor`
- 在更高层面统计（如在 `poll_frame` 层面）
- 使用自定义的 `Body` 实现完全替代默认实现

### 8.2 统一的流量统计抽象

创建统一的 trait：

```rust
trait TrafficCounter {
    fn record_bytes(&self, bytes: u64, direction: Direction);
}

enum Direction {
    Inbound,   // 入站
    Outbound,  // 出站
}
```

### 8.3 更细粒度的统计

- 区分请求头和请求体
- 区分响应头和响应体
- 统计不同 HTTP 方法的流量分布
- 统计不同状态码的响应流量

---

## 总结

反向代理的流量统计通过两种互补的方式实现：

1. **CounterHyperIO**: 在 TCP/IO 连接层统计出站流量（请求发送）
2. **CounterBody**: 在 HTTP Body Stream 层统计入站流量（响应接收）

两者配合使用，提供了完整的反向代理流量可观测性。选择合适的统计方式取决于具体的需求场景和统计粒度要求。
